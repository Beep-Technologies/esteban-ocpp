// Code generated by schema-generate. DO NOT EDIT.

package ocpp16

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// ChargingSchedule 
type ChargingSchedule struct {
  ChargingRateUnit string `json:"chargingRateUnit"`
  ChargingSchedulePeriod []*ChargingSchedulePeriodItems `json:"chargingSchedulePeriod"`
  Duration int `json:"duration,omitempty"`
  MinChargingRate float64 `json:"minChargingRate,omitempty"`
  StartSchedule string `json:"startSchedule,omitempty"`
}

// ChargingSchedulePeriodItems 
type ChargingSchedulePeriodItems struct {
  Limit float64 `json:"limit"`
  NumberPhases int `json:"numberPhases,omitempty"`
  StartPeriod int `json:"startPeriod"`
}

// GetCompositeScheduleResponse 
type GetCompositeScheduleResponse struct {
  ChargingSchedule *ChargingSchedule `json:"chargingSchedule,omitempty"`
  ConnectorId int `json:"connectorId,omitempty"`
  ScheduleStart string `json:"scheduleStart,omitempty"`
  Status string `json:"status"`
}

func (strct *ChargingSchedule) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ChargingRateUnit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "chargingRateUnit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"chargingRateUnit\": ")
	if tmp, err := json.Marshal(strct.ChargingRateUnit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ChargingSchedulePeriod" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "chargingSchedulePeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"chargingSchedulePeriod\": ")
	if tmp, err := json.Marshal(strct.ChargingSchedulePeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "duration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"duration\": ")
	if tmp, err := json.Marshal(strct.Duration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minChargingRate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minChargingRate\": ")
	if tmp, err := json.Marshal(strct.MinChargingRate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "startSchedule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startSchedule\": ")
	if tmp, err := json.Marshal(strct.StartSchedule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChargingSchedule) UnmarshalJSON(b []byte) error {
    chargingRateUnitReceived := false
    chargingSchedulePeriodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "chargingRateUnit":
            if err := json.Unmarshal([]byte(v), &strct.ChargingRateUnit); err != nil {
                return err
             }
            chargingRateUnitReceived = true
        case "chargingSchedulePeriod":
            if err := json.Unmarshal([]byte(v), &strct.ChargingSchedulePeriod); err != nil {
                return err
             }
            chargingSchedulePeriodReceived = true
        case "duration":
            if err := json.Unmarshal([]byte(v), &strct.Duration); err != nil {
                return err
             }
        case "minChargingRate":
            if err := json.Unmarshal([]byte(v), &strct.MinChargingRate); err != nil {
                return err
             }
        case "startSchedule":
            if err := json.Unmarshal([]byte(v), &strct.StartSchedule); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if chargingRateUnit (a required property) was received
    if !chargingRateUnitReceived {
        return errors.New("\"chargingRateUnit\" is required but was not present")
    }
    // check if chargingSchedulePeriod (a required property) was received
    if !chargingSchedulePeriodReceived {
        return errors.New("\"chargingSchedulePeriod\" is required but was not present")
    }
    return nil
}

func (strct *ChargingSchedulePeriodItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Limit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "limit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"limit\": ")
	if tmp, err := json.Marshal(strct.Limit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "numberPhases" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"numberPhases\": ")
	if tmp, err := json.Marshal(strct.NumberPhases); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StartPeriod" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "startPeriod" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startPeriod\": ")
	if tmp, err := json.Marshal(strct.StartPeriod); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChargingSchedulePeriodItems) UnmarshalJSON(b []byte) error {
    limitReceived := false
    startPeriodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "limit":
            if err := json.Unmarshal([]byte(v), &strct.Limit); err != nil {
                return err
             }
            limitReceived = true
        case "numberPhases":
            if err := json.Unmarshal([]byte(v), &strct.NumberPhases); err != nil {
                return err
             }
        case "startPeriod":
            if err := json.Unmarshal([]byte(v), &strct.StartPeriod); err != nil {
                return err
             }
            startPeriodReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if limit (a required property) was received
    if !limitReceived {
        return errors.New("\"limit\" is required but was not present")
    }
    // check if startPeriod (a required property) was received
    if !startPeriodReceived {
        return errors.New("\"startPeriod\" is required but was not present")
    }
    return nil
}

func (strct *GetCompositeScheduleResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "chargingSchedule" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"chargingSchedule\": ")
	if tmp, err := json.Marshal(strct.ChargingSchedule); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "connectorId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"connectorId\": ")
	if tmp, err := json.Marshal(strct.ConnectorId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scheduleStart" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scheduleStart\": ")
	if tmp, err := json.Marshal(strct.ScheduleStart); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GetCompositeScheduleResponse) UnmarshalJSON(b []byte) error {
    statusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "chargingSchedule":
            if err := json.Unmarshal([]byte(v), &strct.ChargingSchedule); err != nil {
                return err
             }
        case "connectorId":
            if err := json.Unmarshal([]byte(v), &strct.ConnectorId); err != nil {
                return err
             }
        case "scheduleStart":
            if err := json.Unmarshal([]byte(v), &strct.ScheduleStart); err != nil {
                return err
             }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            statusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if status (a required property) was received
    if !statusReceived {
        return errors.New("\"status\" is required but was not present")
    }
    return nil
}
